LC3
===

LC-3 processor
===

#Instructions

##LEA
not implemented

##LDR
not implemented

##STR
not implemented

##LD
not implemented

##ST
not implemented

##BR
BR is implemented in the RegPC circuit

##JMP
JMP is implemented in the RegPC circuit

##ADC
ADC is implemented in the ALU, and the overflow has its own circuit : overflow.

##JSR
not implemented

##JSRR
not implemented

##LDI
not implemented

##STI
not implemented

===

#Modules

##DecodeIR
DecodeIR has been completed simply by testing bits 13-12 (meaning the second part of the op-code). They give the family of the instruction : 01 for Arith, 00 for Jump, 10 for Load, 11 for Store.  
At the beginning, I was using AND gates with NOT for the 0. Thus, Arith was 
*AND(NOT(13),12)*. But I changed this for NOR gates, using the dual thought : Arith is *NOR(13,NOT(12))*.  
WriteReg is active if the instruction is a Load or an Arith.

##NZP
I placed a 3 1-bit registers called N, Z and P.
Assuming RES’s bit 15 gives the sign, the circuit computes if RES is negative (bit 15 is 1), null (all bits are 0), or positive (bit 15 is 0, but at least one other is 1). This gives 3 bits matching NZP states. If WriteReg is active, the state given by RES will be written is the register NZP. 
On the other hand, we check if NZP matches IR’s bits for nzp (bits 11|10|9). If every condition is verified, TestNZP will be active (no matter if the instruction really needs NZP, it is checked somewhere else).

##ALU
I added 1 input and 1 output : the previous overflow state, and the overflow generated by the current operation. But as  we compute ADD and ADC at the same time, we must choose (with the opcode) which carry we should keep (ADC could generate a carry where ADD would not). That's why there is a multiplexer. The overflow state is described in the next section.

##Overflow
The overflow register can take two values : 
* 1 if an ADD or ADC has generated an overflow.
* 0 for all others operations modifying NZP : other ARITH and JUMPS.
I should test if the current operation if ADD or ADC in order to choose the next state : that's the goal of the multiplexer, whose selecting bit is the result of a checking on the op-code.
But the next state may not be written : the register is updated only if we have an NZP instruction or an ADD/ADC (but they are NZP instructions too).
Finally, the state is directed to an output.

##RegPC 
First, RegPC computes PC+1. We then compute PC+[SEXT(off9)] for BR. I placed a multiplexer here, because if BR's test fails, the next adresse should be PC+1 anyway. 
We check after what kind of jump we have thanks to the opcode, controlling a plexer : if it is a BR, we choose either PC+1 of PC+[SEXT-off9)], depending on the previous result; if it is a JMP, we just choose the register. 
Finally, a third multiplexer chosses the final value of PC : if the instruction is not even a jump, the new PC should be PC+1. Otherwise, it takes the previous value : PC+1 (BR failed), PC+SEXT(off9) (BR matches), Reg (JMP).

##GetAddr


===
#Tests

##LEA

##STR

##LD

##ST

##BR

##JMP

##ADC

##JSR

##JSRR

##LDI

##STI

